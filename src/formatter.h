/*
webalizer - a web server log analysis program

Copyright (c) 2004-2022, Stone Steps Inc. (www.stonesteps.ca)

See COPYING and Copyright files for additional licensing and copyright information

formatter.h
*/
#ifndef FORMATTER_H
#define FORMATTER_H

#include "tstring.h"
#include "exception.h"

#include <cstddef>
#include <stack>
#include <vector>

///
/// @brief  A generic formatter class that uses the specified formatting function to 
///         render one or more strings within the specified buffer
///
/// `buffer_formatter_t` uses a formatting function passed into the format method to 
/// generate formatted text within the buffer of a given size associated with each 
/// instance of a buffer formatter.
///
/// Using a formatting function in the format method makes it possible to use different 
/// formatting functions with the same formatter and buffer.
///
/// The formatter does not own the buffer and will leave the buffer intact when the
/// formatter is destroyed.
///
/// The formatter supports two formatting modes - overwrite and append. The former 
/// uses the same buffer space every time the format method is called and the latter
/// keeps adding formatted text to the unused space within the existing buffer.
///
/// A scoped formatter may be used to switch the formatter mode temporarily. For example, 
/// `cp1` and `cp2` below will be formatted within the same buffer space, while `cp3` and 
/// `cp4` will be formatted one after another (note the comma after `set_scope_mode` is 
/// called):
/// ```
///    buffer_formatter_t<x> format(buffer, bufsize, buffer_formatter_t<x>::overwrite);
///
///    printf("%s\n", format(fmt_func, cp1));
///    printf("%s\n", format(fmt_func, cp2));
///
///    format.set_scope_mode(buffer_formatter_t<x>::append),
///    printf("%s %s\n", format(fmt_func, cp3), format(fmt_func, cp4));
/// ```
/// Instances of `buffer_formatter_t` cannot be copied because the formatting buffer is
/// supplied externally and there would be no buffer for the copy. Reusing the unused
/// space within the copy of the original formatter would be error-prone because the
/// original formatter could overwrite formatter text generated by a copy formatter.
///
class buffer_formatter_t {
   public:
      ///
      /// @brief  Defines how the formatter uses the available buffer space.
      ///
      enum mode_t {
         overwrite,              ///< Overwrite buffer contents when formatting new output.
         append                  ///< Append new output to the existing buffer contents.
      };

      ///
      /// @brief  A class that keeps track of the previous formatter for each C++ scope
      ///
      /// `scope_t` keeps track of the current formatter state in the associated C++ scope.
      /// All `scope_t` instances returned by a formatter refer to that formatter, which 
      /// maintains a stack of intermediate formatter states.
      ///
      /// `scope_t` only supports move semantics, so only one formatter state is popped for 
      /// every `scope_t` instance returned by `buffer_formatter_t::set_scope_mode`.
      ///
      class scope_t {
         private:
            buffer_formatter_t   *formatter;          ///< The formatter that created this scope.

            size_t               scopeid;             ///< One-based scope identifier to ensure that scopes 
                                                      ///< are destroyed in the proper order.

         public:
            scope_t(const scope_t& other) = delete;
            scope_t& operator = (const scope_t& other) = delete;

            scope_t(buffer_formatter_t& formatter, size_t scopeid) : formatter(&formatter), scopeid(scopeid) 
            {
            }

            scope_t(scope_t&& other) noexcept : formatter(other.formatter), scopeid(other.scopeid)
            {
               // leave scopeid in the other formatter for troubleshooting
               other.formatter = nullptr;
            }

            ~scope_t(void) 
            {
               if(formatter)
                  formatter->pop_scope(scopeid);
            }

            scope_t& operator = (scope_t&& other) noexcept
            {
               formatter = other.formatter;
               scopeid = other.scopeid;

               // leave scopeid in the other formatter for troubleshooting
               other.formatter = nullptr;

               return *this;
            }
      };

   private:
      ///
      /// @brief  Keeps track of states for all formatters in outer C++ scopes
      ///
      /// Every time a new formatter scope is created, the original formatter state
      /// is pushed onto a stack in a fmt_state_t descriptor.
      ///
      struct fmt_state_t {
         char        *cptr;            ///< Saved copy of `buffer_formatter_t::cptr`.
         mode_t      mode;             ///< Saved copy of `buffer_formatter_t::mode`.

         fmt_state_t(char *cptr, mode_t mode) : cptr(cptr), mode(mode) {}
      };

   private:
      char           *const buffer;    ///< A pointer to a formatting buffer.
      char           *cptr;            ///< First unused byte within `buffer`.
      const size_t   bufsize;          ///< Size of the entire buffer, in characters.
      mode_t         mode;             ///< Indicates whether `cptr` moves after each `format` call or not.

      std::stack<fmt_state_t, std::vector<fmt_state_t>> scopes;  ///< Saved formatter scope state descriptors.

   private:
      void pop_scope(size_t scopeid);

   public:
      /// Buffer formatters cannot be copied. 
      buffer_formatter_t(const buffer_formatter_t& other) = delete;

      /// Buffer formatter cannot be copied.
      buffer_formatter_t& operator = (const buffer_formatter_t& other) = delete;

      /// Constructs a buffer formatter with the specified buffer.
      buffer_formatter_t(char *buffer, size_t bufsize, mode_t mode);

      template <typename format_cb_t, typename ... format_param_t>
      string_t::char_buffer_t format(format_cb_t&& formatcb, format_param_t&& ... arg);

      /// Calls `format` to do all formatting work and is intended for formatter instances named as verbs. 
      template <typename format_cb_t, typename ... format_param_t>
      const char *operator () (format_cb_t&& formatcb, format_param_t&& ... arg);

      /// Sets the new buffer formatting mode. 
      void set_mode(mode_t newmode) {mode = newmode;}

      /// Stores the current formatter state internally and returns a scope object with the new formatter state.
      scope_t set_scope_mode(mode_t newmode);
};

#endif // FORMATTER_H
